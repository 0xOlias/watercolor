const xs_state=Uint32Array.from([0,0,0,0].map((_,i)=>parseInt(window.tokenData.hash.substr(8*i+2,8),16))),randDec=()=>{let s,t=xs_state[3];return xs_state[3]=xs_state[2],xs_state[2]=xs_state[1],xs_state[1]=s=xs_state[0],t^=t<<11,t^=t>>>8,xs_state[0]=t^s^s>>>19,xs_state[0]/4294967296},randNum=(a,b)=>a+(b-a)*randDec(),randInt=(a,b)=>Math.floor(randNum(a,b+1)),randGaussian=()=>{var _Mathcos=Math.cos,_MathPI=Math.PI,_Mathsqrt=Math.sqrt,_Mathlog=Math.log;const u=1-randDec(),v=1-randDec();let num=_Mathsqrt(-2*_Mathlog(u))*_Mathcos(2*_MathPI*v);return num=num/10+.5,1<num||0>num?randGaussian():num},WINDOW_HEIGHT=window.innerHeight,HEIGHT=WINDOW_HEIGHT,WIDTH=HEIGHT,PADDING=.15*WIDTH,TIERS=4,SECONDARY_ITERATIONS=3,LAYER_COUNT=50,SIDE_MAGNITUDE_MIN=.4,SIDE_MAGNITUDE_MAX=1.7,MIN_SATURATION=70,MAX_SATURATION=95,MIN_LIGHTNESS=40,MAX_LIGHTNESS=70,deformVertices=(vertices,magnitudeModifiers)=>{const result=[];for(let n=0;n<vertices.length;n++){const magnitudeModifier=magnitudeModifiers[Math.floor(magnitudeModifiers.length*(n/vertices.length))],[x0,y0]=vertices[n],[x1,y1]=vertices[n+1<vertices.length?n+1:0],sideLength=Math.sqrt((x1-x0)**2+(y1-y0)**2),gamma=Math.atan((y1-y0)/(x1-x0)),t=randGaussian(),magnitude=sideLength*randGaussian()*magnitudeModifier,theta=Math.PI*randGaussian(),finalX=(1-t)*x0+t*x1+(x1<x0?1:-1)*magnitude*Math.cos(theta+gamma),finalY=(1-t)*y0+t*y1+(x1<x0?1:-1)*magnitude*Math.sin(theta+gamma);result.push([x0,y0]),result.push([finalX,finalY])}return result},generateBlotLayers=({blotHue,sides,radius,xCenter,yCenter})=>{var _MathPI2=Math.PI;const layers=[],magnitudeModifiers=[...Array(sides)].map(()=>SIDE_MAGNITUDE_MIN+randGaussian()*(SIDE_MAGNITUDE_MAX-SIDE_MAGNITUDE_MIN)),regularVertices=[];for(let n=0;n<sides;n++){const x=xCenter+radius*Math.cos(2*_MathPI2*n/sides),y=yCenter+radius*Math.sin(2*_MathPI2*n/sides);regularVertices.push([x,y])}let baseVertices=regularVertices;for(let i=0;i<TIERS;i++){baseVertices=deformVertices(baseVertices,magnitudeModifiers);for(let secondaryVertices,j=0;j<LAYER_COUNT/TIERS;j++){secondaryVertices=baseVertices;for(let k=0;k<SECONDARY_ITERATIONS;k++)secondaryVertices=deformVertices(secondaryVertices,magnitudeModifiers);const layerHue=(Math.floor(blotHue+100*(.5-randGaussian()))+360)%360;layers.push({layerHue:layerHue,vertices:secondaryVertices})}}return layers},drawPolygon=(vertices,colorString)=>{fill(color(colorString)),beginShape();for(let n=0;n<vertices.length;n++)vertex(vertices[n][0],vertices[n][1]);endShape(CLOSE)},SATURATION=randInt(MIN_SATURATION,MAX_SATURATION),LIGHTNESS=randInt(MIN_LIGHTNESS,MAX_LIGHTNESS),LAYER_ALPHA=1/LAYER_COUNT,HUE_BG=randInt(0,360),SATURATION_BG=randInt(25,35),LIGHTNESS_BG=123-SATURATION_BG,blotLayers=[];function setup(){createCanvas(WIDTH,HEIGHT),noStroke(),background(color(`hsla(${HUE_BG}, ${SATURATION_BG}%, ${LIGHTNESS_BG}%, 1)`));const rowCount=randInt(2,8),columnCount=randInt(2,8),positionDeviation=70;for(let i=0;i<rowCount;i++){const clusterHue=randInt(0,360);for(let j=0;j<columnCount;j++){const blotHue=clusterHue+25*(.5-randGaussian()),sides=randInt(3,5),radius=randInt(10,15);let xCenter=j*((WIDTH-2*PADDING)/(columnCount-1))+PADDING,yCenter=i*((HEIGHT-2*PADDING)/(rowCount-1))+PADDING;xCenter+=positionDeviation*(.5-randGaussian()),yCenter+=positionDeviation*(.5-randGaussian());const layers=generateBlotLayers({blotHue,sides,radius,xCenter,yCenter});blotLayers.push(layers)}}}let currentLayer=0;function draw(){blotLayers.forEach(blotLayer=>{const{layerHue,vertices}=blotLayer[currentLayer];drawPolygon(vertices,`hsla(${layerHue},${SATURATION}%,${LIGHTNESS}%,${LAYER_ALPHA})`)}),currentLayer+=1,currentLayer===LAYER_COUNT&&noLoop()}